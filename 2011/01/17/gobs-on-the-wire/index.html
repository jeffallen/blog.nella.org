<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Gobs on the wire | jra&#39;s thoughts</title>
<meta name="keywords" content="">
<meta name="description" content="This week, I want to talk about how to use Go to write a client/server system with both synchronous requests and asynchronous event notifications.
To help learn Go, I wrote a clone of the Conserver console server. Now, of course, the world didn&rsquo;t need another console server, but it turned out to be an interesting experiment, because what a console server does is well suited to the tools Go gives a programmer. A console server&rsquo;s job is to gather the output from one or more serial cables (or, when there&rsquo;s a terminal server in the mix, one or more TCP connections implementing the Rtelnet &ldquo;protocol&rdquo;). It logs that output to files, and makes the output available in realtime to zero or more watchers. It allows one and only one of the watchers to be read-write, to actually control the device.">
<meta name="author" content="jra">
<link rel="canonical" href="https://blog.nella.org/2011/01/17/gobs-on-the-wire/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3beea2776320e39a6c8d0589cd10cf4cbbbe3ca9b6f0363cfeef1417ed39a195.css" integrity="sha256-O&#43;6id2Mg45psjQWJzRDPTLu&#43;PKm28DY8/u8UF&#43;05oZU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.nella.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.nella.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.nella.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.nella.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.nella.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.nella.org/2011/01/17/gobs-on-the-wire/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend&display=swap" rel="stylesheet">
<meta property="og:url" content="https://blog.nella.org/2011/01/17/gobs-on-the-wire/">
  <meta property="og:site_name" content="jra&#39;s thoughts">
  <meta property="og:title" content="Gobs on the wire">
  <meta property="og:description" content="This week, I want to talk about how to use Go to write a client/server system with both synchronous requests and asynchronous event notifications.
To help learn Go, I wrote a clone of the Conserver console server. Now, of course, the world didn’t need another console server, but it turned out to be an interesting experiment, because what a console server does is well suited to the tools Go gives a programmer. A console server’s job is to gather the output from one or more serial cables (or, when there’s a terminal server in the mix, one or more TCP connections implementing the Rtelnet “protocol”). It logs that output to files, and makes the output available in realtime to zero or more watchers. It allows one and only one of the watchers to be read-write, to actually control the device.">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2011-01-17T18:24:54+00:00">
    <meta property="article:modified_time" content="2011-01-17T18:24:54+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gobs on the wire">
<meta name="twitter:description" content="This week, I want to talk about how to use Go to write a client/server system with both synchronous requests and asynchronous event notifications.
To help learn Go, I wrote a clone of the Conserver console server. Now, of course, the world didn&rsquo;t need another console server, but it turned out to be an interesting experiment, because what a console server does is well suited to the tools Go gives a programmer. A console server&rsquo;s job is to gather the output from one or more serial cables (or, when there&rsquo;s a terminal server in the mix, one or more TCP connections implementing the Rtelnet &ldquo;protocol&rdquo;). It logs that output to files, and makes the output available in realtime to zero or more watchers. It allows one and only one of the watchers to be read-write, to actually control the device.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.nella.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Gobs on the wire",
      "item": "https://blog.nella.org/2011/01/17/gobs-on-the-wire/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Gobs on the wire",
  "name": "Gobs on the wire",
  "description": "This week, I want to talk about how to use Go to write a client/server system with both synchronous requests and asynchronous event notifications.\nTo help learn Go, I wrote a clone of the Conserver console server. Now, of course, the world didn\u0026rsquo;t need another console server, but it turned out to be an interesting experiment, because what a console server does is well suited to the tools Go gives a programmer. A console server\u0026rsquo;s job is to gather the output from one or more serial cables (or, when there\u0026rsquo;s a terminal server in the mix, one or more TCP connections implementing the Rtelnet \u0026ldquo;protocol\u0026rdquo;). It logs that output to files, and makes the output available in realtime to zero or more watchers. It allows one and only one of the watchers to be read-write, to actually control the device.\n",
  "keywords": [
    
  ],
  "articleBody": "This week, I want to talk about how to use Go to write a client/server system with both synchronous requests and asynchronous event notifications.\nTo help learn Go, I wrote a clone of the Conserver console server. Now, of course, the world didn’t need another console server, but it turned out to be an interesting experiment, because what a console server does is well suited to the tools Go gives a programmer. A console server’s job is to gather the output from one or more serial cables (or, when there’s a terminal server in the mix, one or more TCP connections implementing the Rtelnet “protocol”). It logs that output to files, and makes the output available in realtime to zero or more watchers. It allows one and only one of the watchers to be read-write, to actually control the device.\nThe Go version of the console server is called gocons. Go have a look at it, and then come back here. As usual, I want to point out some things I learned about Go while writing it.\nMy first attempt at making this thing work was with netchan. I thought it would be cool if the client could send in a request to the server asking to be notified on a certain channel when events happened on a certain console. But that crashed and burned because netchan can’t send channels. I think it would be theoretically possible to put the right stuff together to make it possible for netchan to send channels, but it would obviously be really hard, and the semantics of the channels would never really be the same. So, moving right along…\nThe next idea was to use the rpc package to implement the protocol between the client and the server. But that ran up onto another problem; RPC, by its very definition is synchronous. There is no clear way to use the RPC package to let the server send down asynchronous events to the client, like “these bytes arrived”. What I needed was to write my own wire protocol, one that could do both synchronous calls like “Can I listen to this? Yes.” and also asynchronous events like, “the console you are watching just output these bytes”. I’ve written protocols before, and it’s not hard, just a bit finicky. But Go provides the gob package, and that’s all you need to make a protocol.\nSo what you do is define types that represent the protocol messages and then let gob take responsibility for marshalling and unmarshalling, as well as figuring out the message delimiters. In our case, the types are called connReq and connReply. In a perfect world, these would be public types in some library, and the client and the server would both use them. In gocons, I got lazy and just copied and pasted them. The client does a gob.Decode on the net.TCPConn, and the result has to be a connReq (if it isn’t, something went wrong, and the client could either kill the connection, or try to decode the next thing on the connection). Because Go doesn’t have unions (they aren’t type safe) the connReq and connReply have to have all the fields in them that could be needed, even if a given protocol message doesn’t use them all. I haven’t calculated the protocol overhead of this, but because the potentially unused fields are things like byte slices and strings, it can’t be much; and empty byte slice will be encoded as a nil, not as a bunch of zeros for the whole underlying byte buffer.\nA more sophisticated version of this idea might be to make a heirarchy of types, the base one being the simplest (with only an int in it to indicate the type) and the more complicated ones embedding the base one. But it’s hard to know what type you’d give to gob.Decode to write into; it seems like you’d have to separate out the two halves of the protocol message and send them with two calls to go.Encode. The first would be the int telling what kind it is, then the second gob would be precisely the right “shape” for the data. In any case, I didn’t do it that way for gocons. Simpler is better!\nIn the server, there are two pieces of code that are kind of interesting. One is the use of JSON for the config file format. The other is how incoming data it sent out to all the listeners.\nFirst the simple one. It’s just an example of how to grab data out of a JSON file without using json.Unmarshall. I didn’t understand it, so while playing with json.Decode, I managed to get this working, and just left it at that. I don’t claim this is nice or pretty, but it works, and it might be useful to other people looking for examples on how to read JSON in Go.\nThe expected input is something like this:\n{ \"consoles\": { \"firewall\": \"ts.company.com:2070\", \"web01\": \"ts.company.com:2071\", \"web02\": \"ts.company.com:2072\", \"web03\": \"ts.company.com:2073\" } } The goal is to call addConsole once for each of the key/value pairs in the consoles hash.\nHere’s how, if you don’t want to (or know how to) use json.Unmarshal:\nr, err := os.Open(*config, os.O_RDONLY, 0) if err != nil { log.Exitf(\"Cannot read config file %v: %v\", *config, err) } dec := json.NewDecoder(r) var conf interface{} err = dec.Decode(\u0026conf) if err != nil { log.Exit(\"JSON decode: \", err) } hash, ok := conf.(map[string]interface{}) if !ok { log.Exit(\"JSON format error: got %T\", conf) } consoles, ok := hash[\"consoles\"] if !ok { log.Exit(\"JSON format error: key consoles not found\") } c2, ok := consoles.(map[string]interface{}) if !ok { log.Exitf(\"JSON format error: consoles key wrong type, %T\", consoles) } for k, v := range c2 { s, ok := v.(string) if ok { addConsole(k, s) } else { log.Exit(\"Dial string for console %v is not a string.\", k) } } The general pattern here is that json.Decode gives you interface{}, and you need to use type selectors to work your way down the structure, and actually get the stuff you expect to be there out of it.\nAn infinitely prettier way to do this is to use json.Unmarshal. It’s a bit hard to understand from the docs, but this blog post makes it crystal clear.\nThe server is made up of a series of goroutines each running in blocking loops to handle their bit of i/o. Each console that is monitored has a read goroutine and a write one. The reader brings bytes in from it, and dispatches them to all the gocons clients who are listening. It maintains the list of clients in a linked list, but another data structure would work as well. The key is that the clients are not stored in the list as net.TCPConn’s, but as channels. What’s watching the other end of those channels for new data is the client’s proxy goroutine. Each time a client connects, a pair of goroutines are created, one for read, one for write. This allows us to do blocking reads on the input (search for dec.Decode for an example) without worrying about blocking other jobs in the server.\nBy keeping one single goroutine in charge of writing over the TCP connection, you don’t have to do any locking. You could, in principle, have multiple console managers all saying, “I’ve got something that should be multiplexed onto that TCP connection!” but not worry about them stomping on each other while writing to the connection. (The current implementation only listens to one console at a time.)\nHere’s a snippet showing how we package up and send the notification that something new arrived on to all the console watchers:\nselect { // a bunch of other channels to monitor here... case data := \u003c-m.dataCh: if closed(m.dataCh) { break L } // multicast the data to the listeners for l := listeners; l != nil; l = l.next { if closed(l.ch) { // TODO: need to remove this node from the list, not just mark nil l.ch = nil log.Print(\"Marking listener \", l, \" no longer active.\") } if l.ch != nil { ok := l.ch \u003c- consoleEvent{data} if !ok { log.Print(\"Listener \", l, \" lost an event.\") } } } So, we make a new consoleEvent and send it to each listener. This is a bit wasteful: it makes a lot of garbage, which means the garbage collector will need to work harder. It might have been possible to make one consoleEvent, then send the same one to all the listeners. But if you are going to share memory like that, it is up to the programmer to insure that the receivers of the shared memory either treat it as read only, or use a mutex to control access to it. In our case, it is used in a read-only way, but far away in the code:\n// new event arrived from the console manager, so send it down the TCP connection case ev := \u003c-evCh: reply.code = Data reply.data = ev.data err := enc.Encode(reply) if err != nil { log.Print(\"connection \", c.rw, \", failed to send data: \", err) break L } This model, of two goroutines per thing that needs reading and writing, is magic. It dramatically reduced the code needed to implement gocons. The original console server has hundreds of lines of complicated code worrying about setting up the select mask, waiting on select, deciding if the signaled fd needs an accept(), or a read() or whatever (and finding the right data structures that correspond to the fd that just became usable). In gocons, and other idiomatic Go programs like the http server implemented in package http, you use blocking reads, and let the Go runtime arrange for the system has a whole to not block.\nIt is interesting to think about what would happen if writing to a client TCP connection were to block, though. As the blockingness is transitive in this system as written, it would eventually back up and block the thing that’s supposed to be reading from the console, blocking all other clients. To protect against that, you need to put some firewalls in place; shared resources should not let individuals block them. You’d need to put short queues on the channels between the client proxy goroutines and the console manager reading goroutine, then have it do non-blocking writes on the channel, and if one would block, do something about it. For example, it could close the channel, in order to say, “hey, you’re not draining things, and you need to clean up your act and come back to me later”.\nWriting and debugging this server in Go made me learn a bunch of things. I’ve still got lots to learn; the code still has some mysteries in it, like why I need a runtime.Gosched() to keep things from blocking, and how to deal with the fact that a closed channel causes a select to always fire on it. There’s another workaround for a mystery hidden in setOwner: my first approach uncovered a bug (in the Go runtime, or in my understanding of it) that I had to workaround with a “pump goroutine” that forwards data from one place to another.\n",
  "wordCount" : "1870",
  "inLanguage": "en",
  "datePublished": "2011-01-17T18:24:54Z",
  "dateModified": "2011-01-17T18:24:54Z",
  "author":{
    "@type": "Person",
    "name": "jra"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.nella.org/2011/01/17/gobs-on-the-wire/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "jra's thoughts",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.nella.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.nella.org/" accesskey="h" title="jra&#39;s thoughts (Alt + H)">jra&#39;s thoughts</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.nella.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.nella.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Gobs on the wire
    </h1>
    <div class="post-meta"><span title='2011-01-17 18:24:54 +0000 +0000'>January 17, 2011</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;jra

</div>
  </header> 
  <div class="post-content"><p>This week, I want to talk about how to use Go to write a client/server system with both synchronous requests and asynchronous event notifications.</p>
<p>To help learn Go, I wrote a clone of the <a href="http://conserver.com">Conserver console server</a>. Now, of course, the world didn&rsquo;t need another console server, but it turned out to be an interesting experiment, because what a console server does is well suited to the tools Go gives a programmer. A console server&rsquo;s job is to gather the output from one or more serial cables (or, when there&rsquo;s a terminal server in the mix, one or more TCP connections implementing the Rtelnet &ldquo;protocol&rdquo;). It logs that output to files, and makes the output available in realtime to zero or more watchers. It allows one and only one of the watchers to be read-write, to actually control the device.</p>
<p>The Go version of the console server is called <a href="http://code.google.com/p/jra-go/source/browse/#hg%2Fcmd%2Fgocons">gocons</a>. Go have a look at it, and then come back here. As usual, I want to point out some things I learned about Go while writing it.</p>
<p>My first attempt at making this thing work was with <a href="http://golang.org/pkg/netchan">netchan</a>. I thought it would be cool if the client could send in a request to the server asking to be notified on a certain channel when events happened on a certain console. But that crashed and burned because netchan can&rsquo;t send channels. I think it would be theoretically possible to put the right stuff together to make it possible for netchan to send channels, but it would obviously be really hard, and the semantics of the channels would never really be the same. So, moving right along&hellip;</p>
<p>The next idea was to use the <a href="http://golang.org/pkg/rpc">rpc</a> package to implement the protocol between the client and the server. But that ran up onto another problem; RPC, by its very definition is synchronous. There is no clear way to use the RPC package to let the server send down asynchronous events to the client, like &ldquo;these bytes arrived&rdquo;. What I needed was to write my own wire protocol, one that could do both synchronous calls like &ldquo;Can I listen to this? Yes.&rdquo; and also asynchronous events like, &ldquo;the console you are watching just output these bytes&rdquo;. I&rsquo;ve written protocols before, and it&rsquo;s not hard, just a bit finicky. But Go provides the <a href="http://golang.org/pkg/gob">gob</a> package, and that&rsquo;s all you need to make a protocol.</p>
<p>So what you do is define types that represent the protocol messages and then let gob take responsibility for marshalling and unmarshalling, as well as figuring out the message delimiters. In our case, the types are called connReq and connReply. In a perfect world, these would be public types in some library, and the client and the server would both use them. In gocons, I got lazy and just copied and pasted them. The client does a gob.Decode on the net.TCPConn, and the result has to be a connReq (if it isn&rsquo;t, something went wrong, and the client could either kill the connection, or try to decode the next thing on the connection). Because Go doesn&rsquo;t have unions (they aren&rsquo;t type safe) the connReq and connReply have to have all the fields in them that could be needed, even if a given protocol message doesn&rsquo;t use them all. I haven&rsquo;t calculated the protocol overhead of this, but because the potentially unused fields are things like byte slices and strings, it can&rsquo;t be much; and empty byte slice will be encoded as a nil, not as a bunch of zeros for the whole underlying byte buffer.</p>
<p>A more sophisticated version of this idea might be to make a heirarchy of types, the base one being the simplest (with only an int in it to indicate the type) and the more complicated ones embedding the base one. But it&rsquo;s hard to know what type you&rsquo;d give to gob.Decode to write into; it seems like you&rsquo;d have to separate out the two halves of the protocol message and send them with two calls to go.Encode. The first would be the int telling what kind it is, then the second gob would be precisely the right &ldquo;shape&rdquo; for the data. In any case, I didn&rsquo;t do it that way for gocons. Simpler is better!</p>
<p>In the server, there are two pieces of code that are kind of interesting. One is the use of JSON for the config file format. The other is how incoming data it sent out to all the listeners.</p>
<p>First the simple one. It&rsquo;s just an example of how to grab data out of a JSON file without using json.Unmarshall. I didn&rsquo;t understand it, so while playing with json.Decode, I managed to get this working, and just left it at that. I don&rsquo;t claim this is nice or pretty, but it works, and it might be useful to other people looking for examples on how to read JSON in Go.</p>
<p>The expected input is something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    &#34;consoles&#34;: {
</span></span><span style="display:flex;"><span>        &#34;firewall&#34;: &#34;ts.company.com:2070&#34;,
</span></span><span style="display:flex;"><span>        &#34;web01&#34;: &#34;ts.company.com:2071&#34;,
</span></span><span style="display:flex;"><span>        &#34;web02&#34;: &#34;ts.company.com:2072&#34;,
</span></span><span style="display:flex;"><span>        &#34;web03&#34;: &#34;ts.company.com:2073&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The goal is to call addConsole once for each of the key/value pairs in the consoles hash.</p>
<p>Here&rsquo;s how, if you don&rsquo;t want to (or know how to) use json.Unmarshal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>  r, err :<span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>Open(<span style="color:#f92672">*</span>config, os<span style="color:#f92672">.</span>O_RDONLY, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> err <span style="color:#f92672">!=</span> nil {
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>Exitf(<span style="color:#e6db74">&#34;Cannot read config file %v: %v&#34;</span>, <span style="color:#f92672">*</span>config, err)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  dec :<span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>NewDecoder(r)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> conf interface{}
</span></span><span style="display:flex;"><span>  err <span style="color:#f92672">=</span> dec<span style="color:#f92672">.</span>Decode(<span style="color:#f92672">&amp;</span>conf)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> err <span style="color:#f92672">!=</span> nil {
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>Exit(<span style="color:#e6db74">&#34;JSON decode: &#34;</span>, err)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  hash, ok :<span style="color:#f92672">=</span> conf<span style="color:#f92672">.</span>(map[string]interface{})
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>ok {
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>Exit(<span style="color:#e6db74">&#34;JSON format error: got %T&#34;</span>, conf)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  consoles, ok :<span style="color:#f92672">=</span> hash[<span style="color:#e6db74">&#34;consoles&#34;</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>ok {
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>Exit(<span style="color:#e6db74">&#34;JSON format error: key consoles not found&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  c2, ok :<span style="color:#f92672">=</span> consoles<span style="color:#f92672">.</span>(map[string]interface{})
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>ok {
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>Exitf(<span style="color:#e6db74">&#34;JSON format error: consoles key wrong type, %T&#34;</span>, consoles)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> k, v :<span style="color:#f92672">=</span> range c2 {
</span></span><span style="display:flex;"><span>    s, ok :<span style="color:#f92672">=</span> v<span style="color:#f92672">.</span>(string)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ok {
</span></span><span style="display:flex;"><span>      addConsole(k, s)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      log<span style="color:#f92672">.</span>Exit(<span style="color:#e6db74">&#34;Dial string for console %v is not a string.&#34;</span>, k)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>The general pattern here is that json.Decode gives you interface{}, and you need to use type selectors to work your way down the structure, and actually get the stuff you expect to be there out of it.</p>
<p>An infinitely prettier way to do this is to use json.Unmarshal. It&rsquo;s a bit hard to understand from the docs, but <a href="http://blog.golang.org/2011/01/json-and-go.html">this blog post</a> makes it crystal clear.</p>
<p>The server is made up of a series of goroutines each running in blocking loops to handle their bit of i/o. Each console that is monitored has a read goroutine and a write one. The reader brings bytes in from it, and dispatches them to all the gocons clients who are listening. It maintains the list of clients in a linked list, but another data structure would work as well. The key is that the clients are not stored in the list as net.TCPConn&rsquo;s, but as channels. What&rsquo;s watching the other end of those channels for new data is the client&rsquo;s proxy goroutine. Each time a client connects, a pair of goroutines are created, one for read, one for write. This allows us to do blocking reads on the input (search for dec.Decode for an example) without worrying about blocking other jobs in the server.</p>
<p>By keeping one single goroutine in charge of writing over the TCP connection, you don&rsquo;t have to do any locking. You could, in principle, have multiple console managers all saying, &ldquo;I&rsquo;ve got something that should be multiplexed onto that TCP connection!&rdquo; but not worry about them stomping on each other while writing to the connection. (The current implementation only listens to one console at a time.)</p>
<p>Here&rsquo;s a snippet showing how we package up and send the notification that something new arrived on to all the console watchers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    select {
</span></span><span style="display:flex;"><span>      // a bunch of other channels to monitor here...
</span></span><span style="display:flex;"><span>      case data := &lt;-m.dataCh:
</span></span><span style="display:flex;"><span>        if closed(m.dataCh) {
</span></span><span style="display:flex;"><span>          break L
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        // multicast the data to the listeners
</span></span><span style="display:flex;"><span>        for l := listeners; l != nil; l = l.next {
</span></span><span style="display:flex;"><span>          if closed(l.ch) {
</span></span><span style="display:flex;"><span>            // TODO: need to remove this node from the list, not just mark nil
</span></span><span style="display:flex;"><span>            l.ch = nil
</span></span><span style="display:flex;"><span>            log.Print(&#34;Marking listener &#34;, l, &#34; no longer active.&#34;)
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          if l.ch != nil {
</span></span><span style="display:flex;"><span>            ok := l.ch &lt;- consoleEvent{data}
</span></span><span style="display:flex;"><span>            if !ok {
</span></span><span style="display:flex;"><span>              log.Print(&#34;Listener &#34;, l, &#34; lost an event.&#34;)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>So, we make a new consoleEvent and send it to each listener. This is a bit wasteful: it makes a lot of garbage, which means the garbage collector will need to work harder. It might have been possible to make one consoleEvent, then send the same one to all the listeners. But if you are going to share memory like that, it is up to the programmer to insure that the receivers of the shared memory either treat it as read only, or use a mutex to control access to it. In our case, it is used in a read-only way, but far away in the code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    // new event arrived from the console manager, so send it down the TCP connection
</span></span><span style="display:flex;"><span>    case ev := &lt;-evCh:
</span></span><span style="display:flex;"><span>      reply.code = Data
</span></span><span style="display:flex;"><span>      reply.data = ev.data
</span></span><span style="display:flex;"><span>      err := enc.Encode(reply)
</span></span><span style="display:flex;"><span>      if err != nil {
</span></span><span style="display:flex;"><span>        log.Print(&#34;connection &#34;, c.rw, &#34;, failed to send data: &#34;, err)
</span></span><span style="display:flex;"><span>        break L
</span></span><span style="display:flex;"><span>      }
</span></span></code></pre></div><p>This model, of two goroutines per thing that needs reading and writing, is magic. It dramatically reduced the code needed to implement gocons. The original console server has hundreds of lines of complicated code worrying about setting up the select mask, waiting on select, deciding if the signaled fd needs an accept(), or a read() or whatever (and finding the right data structures that correspond to the fd that just became usable). In gocons, and other idiomatic Go programs like the http server implemented in package http, you use blocking reads, and let the Go runtime arrange for the system has a whole to not block.</p>
<p>It is interesting to think about what would happen if writing to a client TCP connection were to block, though. As the blockingness is transitive in this system as written, it would eventually back up and block the thing that&rsquo;s supposed to be reading from the console, blocking all other clients. To protect against that, you need to put some firewalls in place; shared resources should not let individuals block them. You&rsquo;d need to put short queues on the channels between the client proxy goroutines and the console manager reading goroutine, then have it do non-blocking writes on the channel, and if one would block, do something about it. For example, it could close the channel, in order to say, &ldquo;hey, you&rsquo;re not draining things, and you need to clean up your act and come back to me later&rdquo;.</p>
<p>Writing and debugging this server in Go made me learn a bunch of things. I&rsquo;ve still got lots to learn; the code still has some mysteries in it, like why I need a runtime.Gosched() to keep things from blocking, and how to deal with the fact that a closed channel causes a select to always fire on it. There&rsquo;s another workaround for a mystery hidden in setOwner: my first approach uncovered a bug (in the Go runtime, or in my understanding of it) that I had to workaround with a &ldquo;pump goroutine&rdquo; that forwards data from one place to another.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gobs on the wire on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.nella.org%2f2011%2f01%2f17%2fgobs-on-the-wire%2f&amp;title=Gobs%20on%20the%20wire&amp;summary=Gobs%20on%20the%20wire&amp;source=https%3a%2f%2fblog.nella.org%2f2011%2f01%2f17%2fgobs-on-the-wire%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gobs on the wire on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Gobs%20on%20the%20wire&u=https%3a%2f%2fblog.nella.org%2f2011%2f01%2f17%2fgobs-on-the-wire%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
